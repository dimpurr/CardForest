# CardForest 前端代码库改进计划

## 检查清单

### 第一阶段：代码组织和结构优化
- [x] 1.1 统一 GraphQL 查询管理
  - [x] 1.1.1 创建统一的 GraphQL 目录结构
  - [x] 1.1.2 整合所有查询和变更到相应文件
  - [x] 1.1.3 创建共享片段减少重复代码
  - [x] 1.1.4 配置 GraphQL Code Generator
- [x] 1.2 统一类型定义
  - [x] 1.2.1 创建共享类型库
  - [x] 1.2.2 整合现有类型定义
  - [x] 1.2.3 更新 tsconfig.json 启用严格类型检查
- [x] 1.3 统一状态管理
  - [x] 1.3.1 创建统一的 Jotai atoms 目录结构
  - [x] 1.3.2 整合现有 atoms
  - [x] 1.3.3 实现持久化状态（如需要）

### 第二阶段：认证系统重构
- [x] 2.1 统一认证流程
  - [x] 2.1.1 创建统一的认证服务
  - [x] 2.1.2 实现一致的 JWT 处理
  - [x] 2.1.3 统一用户对象格式
- [x] 2.2 创建认证上下文
  - [x] 2.2.1 实现 AuthContext
  - [x] 2.2.2 创建认证钩子（useAuth）
  - [x] 2.2.3 整合现有认证逻辑

### 第三阶段：组件和 API 封装
- [x] 3.1 创建 GraphQL API 封装
  - [x] 3.1.1 封装 Apollo Client 操作
  - [x] 3.1.2 提供类型安全的 API 钩子
  - [x] 3.1.3 统一错误处理
- [x] 3.2 重构 UI 组件
  - [x] 3.2.1 创建可复用的组件
  - [x] 3.2.2 实现组件文档
  - [x] 3.2.3 添加测试

## 详细计划

### 第一阶段：代码组织和结构优化

#### 1.1 统一 GraphQL 查询管理

**当前问题**：
- GraphQL 查询分散在多个文件中
- 存在重复的查询定义（如 `GET_MY_CARDS` 在多个文件中定义）
- 缺乏统一的片段（Fragment）管理
- 没有类型生成，导致类型安全性差

**改进方案**：
1. 创建统一的 GraphQL 目录结构：
   ```
   graphql/
   ├── fragments/
   │   ├── cardFragments.ts
   │   ├── modelFragments.ts
   │   └── userFragments.ts
   ├── mutations/
   │   ├── cardMutations.ts
   │   ├── modelMutations.ts
   │   └── userMutations.ts
   ├── queries/
   │   ├── cardQueries.ts
   │   ├── modelQueries.ts
   │   └── userQueries.ts
   └── types/
       └── generated.ts  // 自动生成的类型
   ```

2. 使用片段（Fragment）减少重复代码：
   - 为卡片、模型和用户创建基础片段
   - 在查询和变更中复用这些片段

3. 配置 GraphQL Code Generator：
   - 安装必要的依赖
   - 创建配置文件
   - 设置生成脚本

#### 1.2 统一类型定义

**当前问题**：
- 前后端类型定义不同步（如 `Model` 接口在多处定义且不一致）
- 缺乏严格的类型检查（`strict: false` 在 tsconfig.json 中）
- 类型定义分散在多个文件中

**改进方案**：
1. 创建共享类型库：
   ```
   types/
   ├── card.ts
   ├── model.ts
   ├── user.ts
   └── index.ts
   ```

2. 整合现有类型定义：
   - 统一 Model、Card、User 等核心类型
   - 确保与后端类型一致

3. 更新 tsconfig.json 启用严格类型检查：
   - 设置 `"strict": true`
   - 逐步修复类型错误

#### 1.3 统一状态管理

**当前问题**：
- Jotai 使用不一致（有些使用 atom，有些使用 useAtom）
- 状态分散在多个文件中（store/、atoms/、stores/）
- 缺乏明确的状态管理策略

**改进方案**：
1. 创建统一的 Jotai atoms 目录结构：
NOTE： 这里先不搞这么多层，统一就在 atoms/ 下叫 xxAtoms 就好。
   ```
   atoms/
   ├── auth/
   │   ├── authAtoms.ts
   │   └── index.ts
   ├── card/
   │   ├── cardAtoms.ts
   │   └── index.ts
   ├── model/
   │   ├── modelAtoms.ts
   │   └── index.ts
   └── index.ts  // 导出所有 atoms
   ```

2. 整合现有 atoms：
   - 将现有的 atoms 移动到相应的文件中
   - 统一命名和使用模式

3. 实现持久化状态（如需要）：
   - 使用 atomWithStorage 持久化关键状态
   - 确保状态在页面刷新后保持

### 第二阶段：认证系统重构

#### 2.1 统一认证流程

**当前问题**：
- 同时存在多种认证流程（前端 NextAuth 和后端直接 OAuth）
- JWT 处理不一致（有时从 session 获取，有时从 cookie 获取，有时从 URL 获取）
- 用户对象格式不统一（有时是对象，有时是字符串 ID）

**改进方案**：
1. 创建统一的认证服务：
   - 封装所有认证相关逻辑
   - 提供一致的 API

2. 实现一致的 JWT 处理：
   - 统一 JWT 获取逻辑
   - 优先级：session > cookie > URL 参数

3. 统一用户对象格式：
   - 创建标准化用户对象
   - 处理不同来源的用户数据

#### 2.2 创建认证上下文

**当前问题**：
- 认证状态管理分散
- 组件需要单独处理认证逻辑
- 缺乏统一的认证 API

**改进方案**：
1. 实现 AuthContext：
   - 创建 React Context 提供认证状态
   - 封装 NextAuth 和自定义认证逻辑

2. 创建认证钩子（useAuth）：
   - 提供统一的认证 API
   - 处理登录、登出和会话管理

3. 整合现有认证逻辑：
   - 替换直接使用 useSession 的地方
   - 统一处理认证状态

### 第三阶段：组件和 API 封装

#### 3.1 创建 GraphQL API 封装

**当前问题**：
- 直接在组件中使用 Apollo Client
- 重复的数据获取和错误处理逻辑
- 缺乏统一的 API 层

**改进方案**：
1. 封装 Apollo Client 操作：
   - 创建服务层抽象 Apollo 操作
   - 统一处理缓存和网络策略

2. 提供类型安全的 API 钩子：
   - 为每个主要实体创建专用钩子
   - 利用生成的类型确保类型安全

3. 统一错误处理：
   - 创建统一的错误处理机制
   - 提供友好的错误消息和恢复选项

#### 3.2 重构 UI 组件

**当前问题**：
- 组件逻辑和表现混合
- 缺乏可复用的组件库
- 缺乏组件文档和测试

**改进方案**：
1. 创建可复用的组件：
   - 分离逻辑和表现
   - 创建领域特定组件

2. 实现组件文档：
   - 使用注释或专门工具记录组件
   - 提供使用示例

3. 添加测试：
   - 为关键组件添加单元测试
   - 确保组件行为一致

## 实施策略

### 优先级和顺序

1. 首先解决最紧急的问题：
   - 统一 GraphQL 查询管理
   - 统一认证流程

2. 然后改进开发体验：
   - 统一类型定义
   - 统一状态管理

3. 最后提高代码质量：
   - 创建 API 封装
   - 重构 UI 组件

### 渐进式实施

- 采用增量方法，避免大规模重写
- 先创建新结构，然后逐步迁移现有代码
- 保持向后兼容，确保功能不中断

### 测试和验证

- 每个改进后进行测试
- 确保现有功能不受影响
- 记录改进和影响

## 预期成果

- 更一致、可维护的代码库
- 更好的开发体验和效率
- 更少的错误和更高的代码质量
- 更容易扩展和添加新功能
